"""GraphQL subscription utilities for CFBD live data."""
from __future__ import annotations

import json
import logging
import os
import threading
import time
import uuid
from dataclasses import dataclass
from typing import Callable, Dict, Optional

from .graphql import GraphQLRequest
from .client import HOST_MAP

try:  # pragma: no cover - optional dependency
    import websocket  # type: ignore
except ImportError:  # pragma: no cover
    websocket = None

_LOGGER = logging.getLogger("cfbd_graphql_subscriptions")
if not _LOGGER.handlers:
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter("%(message)s"))
    _LOGGER.addHandler(handler)
_LOGGER.setLevel(logging.INFO)


@dataclass
class SubscriptionHandle:
    """Handle returned to callers so they can stop a subscription."""

    ws_app: any
    thread: threading.Thread
    heartbeat_thread: Optional[threading.Thread]
    active: bool = True

    def stop(self) -> None:
        if not self.active:
            return
        self.active = False
        try:
            self.ws_app.close()
        finally:
            if self.thread.is_alive():
                self.thread.join(timeout=2)
            if self.heartbeat_thread and self.heartbeat_thread.is_alive():
                self.heartbeat_thread.join(timeout=2)


class GraphQLSubscriptionClient:
    """Minimal GraphQL-over-websocket client with heartbeat and telemetry reporting."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        host: Optional[str] = None,
        telemetry_hook = None,
        websocket_factory=None,
        heartbeat_interval: int = 30,
    ) -> None:
        self._api_key = api_key or os.getenv("CFBD_API_KEY")
        if not self._api_key:
            raise ValueError("CFBD_API_KEY is required for subscriptions")

        host_choice = (host or os.getenv("CFBD_HOST") or "production").lower()
        if host_choice not in HOST_MAP:
            raise ValueError("CFBD_HOST must be one of {'production', 'next'}")

        base_url = HOST_MAP[host_choice]
        self._ws_url = base_url.replace("https://", "wss://").replace("http://", "ws://") + "/graphql"
        self._telemetry_hook = telemetry_hook
        self._websocket_factory = websocket_factory or (websocket.WebSocketApp if websocket else None)
        self._heartbeat_interval = heartbeat_interval

    def subscribe(
        self,
        request: GraphQLRequest,
        on_event: Callable[[Dict[str, Any]], None],
        on_error: Optional[Callable[[Exception], None]] = None,
        operation_name: Optional[str] = None,
    ) -> SubscriptionHandle:
        if self._websocket_factory is None:
            raise RuntimeError(
                "websocket-client is not installed. Install it or provide a custom websocket_factory."
            )

        subscription_id = f"sub_{uuid.uuid4().hex}"

        def _on_open(ws_app):
            init_payload = {
                "type": "connection_init",
                "payload": {"Authorization": f"Bearer {self._api_key}"},
            }
            ws_app.send(json.dumps(init_payload))
            start_payload = {
                "id": subscription_id,
                "type": "start",
                "payload": {
                    "query": request.query,
                    "variables": request.variables or {},
                    "operationName": operation_name or request.operation_name,
                },
            }
            ws_app.send(json.dumps(start_payload))
            self._emit_event("subscription_started", operation_name or request.operation_name, None)

        def _on_message(ws_app, message):
            try:
                payload = json.loads(message)
            except json.JSONDecodeError as exc:
                self._emit_event("subscription_decode_error", operation_name, str(exc))
                if on_error:
                    on_error(exc)
                return

            message_type = payload.get("type")
            if message_type == "data":
                on_event(payload.get("payload", {}).get("data", {}))
            elif message_type == "error":
                err = RuntimeError(str(payload.get("payload")))
                if on_error:
                    on_error(err)
            elif message_type == "connection_error":
                err = RuntimeError("Connection error received from GraphQL subscription")
                if on_error:
                    on_error(err)
            # `ka` keep-alive messages are ignored.

        def _on_error(ws_app, error):
            self._emit_event("subscription_ws_error", operation_name, str(error))
            if on_error:
                on_error(error)

        def _on_close(ws_app, status_code, msg):
            self._emit_event("subscription_closed", operation_name, status_code)

        ws_app = self._websocket_factory(
            self._ws_url,
            header={"Authorization": f"Bearer {self._api_key}"},
            on_open=_on_open,
            on_message=_on_message,
            on_error=_on_error,
            on_close=_on_close,
        )

        ws_thread = threading.Thread(target=ws_app.run_forever, daemon=True)
        ws_thread.start()

        heartbeat_thread = threading.Thread(
            target=self._heartbeat_loop,
            args=(ws_app, subscription_id),
            daemon=True,
        )
        heartbeat_thread.start()

        return SubscriptionHandle(ws_app=ws_app, thread=ws_thread, heartbeat_thread=heartbeat_thread)

    def _heartbeat_loop(self, ws_app, subscription_id: str) -> None:
        while True:
            time.sleep(self._heartbeat_interval)
            try:
                heartbeat_payload = {"type": "ping", "id": subscription_id}
                ws_app.send(json.dumps(heartbeat_payload))
            except Exception as exc:  # pragma: no cover - network/device dependent
                self._emit_event("subscription_heartbeat_error", subscription_id, str(exc))
                break

    def _emit_event(self, outcome: str, operation: Optional[str], detail: Optional[Any]) -> None:
        if self._telemetry_hook:
            self._telemetry_hook(
                {
                    "timestamp": time.time(),
                    "client": "graphql_subscription",
                    "operation": operation,
                    "outcome": outcome,
                    "detail": detail,
                }
            )


__all__ = ["GraphQLSubscriptionClient", "SubscriptionHandle"]
